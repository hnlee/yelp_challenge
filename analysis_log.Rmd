Analysis log
========================================================

### Loading data

* Installed `jsonlite` and `knitr` packages

```{r}
setwd('/Users/hanalee/yelp_challenge')
library(jsonlite)
```

### Quiz questions

Load data and cache for loading
```{r}
business <- stream_in(file("dataset/yelp_academic_dataset_business.json"))
checkin <- stream_in(file("dataset/yelp_academic_dataset_checkin.json"))
review <- stream_in(file("dataset/yelp_academic_dataset_review.json"))
tip <- stream_in(file("dataset/yelp_academic_dataset_tip.json"))
user <- stream_in(file("dataset/yelp_academic_dataset_user.json"))
yelp_data <- save(business, checkin, review, tip, user,
                  file="yelp_data.rda")
```

Exploratory data analysis for quiz 1
```{r}
nrow(review)
review[100,]
colnames(review)
length(which(review$stars==5))/nrow(review)

nrow(business)
colnames(business)
colnames(business$attributes)
length(which(business$attributes[,"Wi-Fi"] == "free"))/sum(!(is.na(business$attributes[,"Wi-Fi"])))

nrow(tip)
tip[1000,]

colnames(user)
colnames(user$votes)
intersect(c("Ira","Brian","Jeff","Roger"), user[which(user$votes[,"funny"] > 10000), "name"])
fisher.test(table(user$votes[,"funny"] > 1, user$fans > 1))
```

### Brainstorming

```{r}
load("yelp_data.rda")
library(dplyr)
library(reshape2)
library(caret)
```

I'm interested in urban planning aspects of the data set. Possible  questions for the project:
* Predict food deserts
* Predict neighborhood popularity (with locals, with tourists)
* Predict neighborhood of a business given the users who review it
* Predict priciness of a neighborhood

Pre-processing steps
* I want to create a variable to code for which metropolitan area
  * Must determine which latitude & longitude ranges are appropriate
  * Use a function to detect clusters
  * Ten cities so k-means where k=10
* Within each city, identify neighborhoods
  * Do neighborhoods overlap?
  * Infer missing values for businesses without neighborhood based on latitude and longitude
* Do I need to be more local than neighborhood?

```{r}
cities <- kmeans(select(business, latitude, longitude), 
                 centers=10, nstart=10000, iter.max=10000)
cities$size
cities$centers
length(cities$cluster)
business$metro <- as.factor(cities$cluster)

cityplot <- ggplot(data=select(business, metro, latitude, longitude)) 
cityplot + geom_point(aes(x=longitude, y=latitude, color=metro))
```

Partitioning steps
* 10% of business_id for test set?

```{r}
length(setdiff(checkin$business_id, business$business_id))
length(setdiff(tip$business_id, business$business_id))
length(setdiff(review$business_id, business$business_id))
```

Need to avoid circularity where what is being predicted is also in the predictors.

Use external data set to determine what to predict?

Predict something about a category of businesses?

Cities can be assigned based on states rather than through k-means

```{r}
levels(as.factor(business$state))
sapply(levels(as.factor(business$state)), function(x) {
  nrow(business[business$state == x,])
})
business$metro <- sapply(business$city, function(x){
  if(x == "AZ"){return("Phoenix")}
  if(x == "IL"){return("Urbana-Champaign")}
  if(x %in% c("NC", "SC")){return("Charlotte")}
  if(x == "NV"){return("Las Vegas")}
  if(x == "PA"){return("Pittsburgh")}
  if(x == "WI"){return("Madison")}
  if(x == "QC"){return("Montreal")}
  if(x == "ON"){return("Waterloo")}
  if(x %in% c("BW", "RP")){return("Karlsruhe")}
  if(x %in% c("EDH", "ELN", "FIF", "HAM", "KHL", "MLN", "NTH", "SCB", "XGL")){
    return("Edinburgh")
  } else { return(NA)}
})
```

### Data cleaning

Check for missing data in: 
  - name
  - longitude
  - latitude
  - state
  - stars
  - review_count
  - open

```{r}
colnames(business)
business_meta <- c("name", "longitude","latitude", "state", "stars","review_count", "open")
colSums(is.na(business[, business_meta]))
business_flat <- business[, business_meta]
```

Expand out:
  - hours X
  - categories
  - attributes X
  - neighborhoods - character(0) needs to be NA

```{r}
head(business$categories, 5)
colnames(business$attributes)
colnames(business$hours)
head(business$neighborhoods, 5)
```

Cleaning up attributes
```{r}
attribute_classes <- sapply(colnames(business$attributes), function(x){ class(business$attributes[,x]) })
attributes <- as.data.frame(business$attributes[, which(attribute_classes == "logical")])

which(attribute_classes == "character")
attributes$`Alcohol` <- as.factor(business$attributes$`Alcohol`)
attributes$`Noise Level` <- as.factor(business$attributes$`Noise Level`)
attributes$`Attire` <- as.factor(business$attributes$`Attire`)
attributes$`Smoking` <- as.factor(business$attributes$`Smoking`)
attributes$`Wi-Fi` <- as.factor(business$attributes$`Wi-Fi`)
attributes$`Ages Allowed` <- as.factor(business$attributes$`Ages Allowed`)
attributes$`BYOB/Corkage` <- as.factor(business$attributes$`BYOB/Corkage`)

which(attribute_classes == "list")
attributes$`Accepts Credit Cards` <- sapply(business$attributes$`Accepts Credit Cards`, function(x){
  if(length(x) == 0) { return(NA) } else { return(x[1]) }
})

head(attributes, 5)

which(attribute_classes == "data.frame")
sapply(colnames(business$attributes$`Ambience`), function(x){ class(business$attributes$`Ambience`[,x]) })
sapply(colnames(business$attributes$`Good For`), function(x){ class(business$attributes$`Good For`[,x]) })
sapply(colnames(business$attributes$`Music`), function(x){ class(business$attributes$`Music`[,x]) })
sapply(colnames(business$attributes$`Hair Types Specialized In`), function(x){ class(business$attributes$`Hair Types Specialized In`[,x]) })
sapply(colnames(business$attributes$`Payment Types`), function(x){ class(business$attributes$`Payment Types`[,x]) })
sapply(colnames(business$attributes$`Parking`), function(x){ class(business$attributes$`Parking`[,x]) })
sapply(colnames(business$attributes$`Dietary Restrictions`), function(x){ class(business$attributes$`Dietary Restrictions`[,x]) })

ambience <- as.data.frame(business$attributes$`Ambience`)
good_for <- as.data.frame(business$attributes$`Good For`)
music <- as.data.frame(business$attributes$`Music`)
hair_types <- as.data.frame(business$attributes$`Hair Types Specialized In`)
payment <- as.data.frame(business$attributes$`Payment Types`)
parking <- as.data.frame(business$attributes$`Parking`)
dietary <- as.data.frame(business$attributes$`Dietary Restrictions`)

```

Cleaning up hours
```{r}
hours <- cbind(sapply(colnames(business$hours), function(x){
    as.numeric(substr(business$hours[,x][,"open"], 1, 2))
  }),
  sapply(colnames(business$hours), function(x){
    as.numeric(substr(business$hours[,x][,"close"], 1, 2))
  })
)
colnames(hours) <- paste(rep(colnames(business$hours), each=2), c("open","close"), sep='_')
hours <- as.data.frame(hours)
head(hours)
```

Cleaning up categories - only use top-level categories from Yelp
```{r}
top_level <- c("Active Life", "Arts & Entertainment", "Automotive", "Beauty & Spas", "Education",
  "Event Planning & Services", "Financial Services", "Food", "Health & Medical", "Home Services",
  "Hotels & Travel", "Local Flavor", "Local Services", "Mass Media", "Nightlife", "Pets", 
  "Professional Services", "Public Services & Government", "Real Estate", "Religious Organizations",
  "Restaurants", "Shopping")
sum(sapply(business$categories, function(x) { length(intersect(top_level, x)) != 1 & length(x) != 0 }))
categories <- as.data.frame(cbind(sapply(top_level, function(x) {
  sapply(business$categories, function(y) {
    x %in% y
  })
})))
```

Ignoring neighborhoods for now -- may later use along with clustering of longitude and latitude

Note that review count does not equal total number of reviews, but total number of users who left reviews.
```{r}
check <- head(business[,c("business_id", "review_count")],5)
colnames(review)
length(which(review$business_id == check$business_id[1]))
review[which(review$business_id == check$business_id[1]), "user_id"]
total_review <- sapply(business$business_id, function(x) {
  length(which(review$business_id == x))
})
```

Add in features:
  - number of tips
  - number of checkins
  - number of repeat reviews
  - number of repeat checkins
  - number of repeat tips
```{r}
total_tip <- sapply(business$business_id, function(x) {
  length(which(tip$business_id == x))
})
total_checkin <- sapply(business$business_id, function(x) {
  length(which(checkin$business_id == x))
})
repeat_review <- sapply(business$business_id, function(x) {
  review_number <- table(review[which(review$business_id == x), "user_id"])
  return(length(which(review_number > 1)))
})
repeat_tip <- sapply(business$business_id, function(x) {
  tip_number <- table(tip[which(tip$business_id == x), "user_id"])
  return(length(which(tip_number > 1)))
})
repeat_checkin <- sapply(business$business_id, function(x) {
  checkin_number <- table(checkin[which(checkin$business_id == x), "user_id"])
  return(length(which(checkin_number > 1)))
})
```

What to predict:
  - stars
  - number of reviews (total or unique?)
  - total of reviews, checkins, tips?
```{r}
mean_stars <- sapply(business$business_id, function(x) {
  return(mean(review[which(review$business_id == x), "stars"]))
})

total_rct <- rowSums(cbind(total_review, total_tip,  total_checkin))
```

Note that stars is actually ordered categorical (steps of 0.5) -- create a star average to predict?
```{r}
ggplot(data=as.data.frame(business[,c("business_id", "stars")])) + geom_histogram(aes(x=stars), binwidth=0.5)
```

Saving everything to reload easily
```{r}
save(business_flat,
  attributes,
  ambience,
  good_for,
  music,
  parking,
  hair_types,
  payment,
  parking,
  dietary,
  hours,
  categories,
  total_review,
  total_tip,
  total_checkin,
  repeat_review,
  repeat_tip,
  repeat_checkin,
  mean_stars,
  total_rct, file="yelp_clean.rda")
business_data <- as.data.frame(cbind(business_flat,
  attributes,
  ambience,
  good_for,
  music,
  parking,
  hair_types,
  payment,
  parking,
  dietary,
  hours,
  categories,
  total_review,
  total_tip,
  total_checkin,
  repeat_review,
  repeat_tip,
  repeat_checkin,
  mean_stars,
  total_rct))
save(business_data, file="yelp_tidy.rda")
```

### Data partitioning

70-30 split into training and test data

```{r}
train_index <- createDataPartition(business$stars, p=0.7, groups=9, list=FALSE)
train <- business_data[train_index,]
test <- business_data[-train_index,]
save(train, file="yelp_train.rda")
save(test, file="yelp_test.rda")
```

